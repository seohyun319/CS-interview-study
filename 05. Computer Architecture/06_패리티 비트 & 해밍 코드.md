## 패리티 비트

- **개념**
    
    > 정보 전달 과정에서 오류가 생겼는지 검사하기 위해 추가하는 비트를 말한다.
    > 
    > 
    > 전송하고자 하는 데이터의 각 문자에 1비트를 더하여 전송한다.
    > 

- **종류**
    
    > 짝수(Even Parity), 홀수(Odd Parity)
    전체 비트에서 (짝수, 홀수)에 맞도록 비트를 정한다.
    > 

- **예시**
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/236d866b-5375-48a2-ae2f-9ea5b351a360/Untitled.png)
    
    위처럼 8-Bit의 데이터 외에 추가적으로 패리티 비트 하나를 추가하여 송수신
    

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e0eaa19c-f672-4473-9ef0-107d4970652d/Untitled.png)

짝수 패리티로 설정할 것인지 혹은 홀수 패리티로 설정할 것인지에 따라서 **붙는 패리티 비트의 값이 달라진다**. (짝수 패리티가 0이고 홀수 패리티가 1인 것은 아님)

**짝수(Even) 패리티**는 실제 송신하고자 하는 데이터의 각 비트의 값 중에서 **1의 개수가 짝수가 되도록 패리티 비트를 정하는 것이다. (**ex. 데이터 비트에서 1의 개수가 홀수이면 패리티 비트를 1로 정함)

위의 그림에서는 데이터의 각 비트의 값 중 1의 개수가 이미 짝수이므로 **짝수 패리티 비트의 값이 0으로 설정되어 있다.**

**홀수(Odd) 패리티**는 전체 비트에서 **1의 개수가 홀수**가 되도록 패리티 비트를 정하는 방법이다. 위의 그림을 봤을 때 1의 개수가 짝수이므로, 이를 홀수로 맞추기 위해서 **홀수 패리티 비트의 값을 1로 설정**한다.

- **응용**
    
    ***짝수 패리티일 때 7비트 데이터가 1010001라면?***
    
    > 1이 총 3개이므로, 짝수로 맞춰주기 위해 1을 더해야 함
    > 
    > 
    > 답 : 11010001 (맨앞이 패리티비트)
    > 

- **사용 이유**
    
    > 데이터를 송수신하는 과정에서 각 비트를 단위 시간당 하나씩 보내는데 이때 알 수 없는 요인에 의해서 비트의 값이 틀어져 1이 0으로 바뀌거나 0이 1로 바뀌었을 때 이를 확인할 수 있도록 하기 위해서이다.
    
    즉, 패리티 비트를 정하여 데이터를 보내면 받는 쪽에서는 수신된 데이터의 전체 비트를 계산하여 패리티 비트를 다시 계산함으로써 **데이터 오류 발생 여부를 알 수 있다**. 그러나 오류를 **수정할 수는 없고** **2개의 bit 오류가 발생**했을 경우는 검출할 수 없다.
    > 

- **사용하는 경우**
    
    > **시리얼 통신의 거리가 상당히 멀 경우**에 주로 적용된다.
    
    송수신 거리가 짧을 경우에는 보통의 경우 패리티 비트는 사용하지 않고, **Checksum 데이터**를 추가한다.
    > 

---

## 해밍 코드

- **개념**
    
    > 데이터 전송 시 오류 검출과 정정을 할 수 있는 코드이다.
    패리티 비트를 보고, 1비트에 대한 오류를 정정할 곳을 찾아 수정할 수 있다. 
    즉, **에러 비트의 위치를 알 수 있을 뿐만 아니라 정정**할 수 있다!
    > 

- **공식**
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8a9d27bf-1ef1-4e3f-87d7-2f9b6cbf0b8c/Untitled.png)
    
    위 공식을 만족하는 p값이어야 하는데, 데이터 비트가 1byte일 때 8bit이므로 p는 최소 4가 되어야 한다.
    
- **삽입 위치**
    
    Little Endian 포맷 
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/02e6a0e5-59b2-4f09-b572-8d5178170ef4/Untitled.png)
    
    총 비트 수는 데이터 8비트, 체크 비트 4비트로 12비트이다.
    
    체크 비트가 4개인데 각 체크 비트는 2^ 위치에 삽입된다 (1, 2, 4, 8 ...)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/0af34610-4149-4f79-8377-32f8257c03f0/Untitled.png)
    
    체크 비트를 각 위치에 삽입한 후,
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/087e9cc4-cb38-459b-bb19-a013f658d580/Untitled.png)
    
    나머지 비트를 순서대로 채워준다. 
    
    수신단에서의 데이터스트림은 이와 같은 형식이 되며 각각의 체크 비트들은 할당된 부분에 패리티 체킹을 수행한다.
    

- **패리티 체킹**
    
    송신된 신호를 기반으로 체크 비트를 모아 놓으면 0101, 0111 등의 비트가 나온다.
    
    그 다음 실제 수신된 체크 비트과 비교하여 에러를 확인한다.
    
    예를 들어, **송신된 신호의 체크비트열은 0011** 인데, **수신된 체크비트가 1001**일 경우에
    
    리틀 엔디안 순서에서 **두 번째 비트**와 **네 번째 비트**에서 기대값과 다른 값이 수신된 결과다.
    
    따라서 오류 확인 비트는 **1010**이 될 것이다. 
    
    이 때 이 수를 Decimal로 읽으면 에러가 생긴 비트를 확인할 수 있다.
    
    1010 = 10이므로, 10번째 비트에 오류가 생긴 것!! 
    
    즉 **수신단에서 D10을 뒤집으면 오류를 정정**할 수 있다.
    
- **예제**
    
    **10011010** 8비트를 수신한다고 가정한다. (짝수 패리티 사용)
    
    ***1) 전송할 코드어 생성***
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7ddc410d-6057-4a7f-abc0-a60f6ceef631/Untitled.png)
    
    **p1**: 1비트 검사, 1비트 건너뜀. 1비트 검사, 1비트 건너뜀을 반복한다. (1, 3, 5, 7, 9, 11 ...)
    
    1이 4개 있기 때문에 짝수라서 p1에 0을 삽입한다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/26365e16-7055-4486-846b-0fb9978ad058/Untitled.png)
    
    **p2**: 2비트 검사, 2비트 건너뜀. 2비트 검사, 2비트 건너뜀을 반복한다. (2, 3, 6, 7, 10, 11 ...)
    
    1이 3개 있기 때문에 홀수라서 p2에는 1을 삽입한다. 
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d264c9a2-6a97-4fc1-b635-ef14c7787bd1/Untitled.png)
    
    **p4**: 4비트 검사, 4비트 건너뜀. 4비트 검사, 4비트 건너뜀을 반복한다. (4, 5, 6, 7, 12 ...)
    
    1이 1개 있기 때문에 홀수라서 p4에 1을 삽입한다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7ac29a31-57a2-4dd6-a99a-403c33238383/Untitled.png)
    
    **p8**: 8비트 검사, 8비트 건너뜀은 반복한다. (8, 9, 10, 11, 12 ...)
    
    1이 2개 있기 때문에 p8에 0을 삽입한다.
    
    전송할 코드어는 다음과 같다.
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5120430c-7edf-45b2-a721-00e132d1d163/Untitled.png)
    
    ***2) 오류 검출과 수정***
    
    d10에서 오류가 검출됐다고 가정한다. (우리는 아직 모르는 상태)
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/72614750-3e66-43b0-90f6-923de7cbba82/Untitled.png)
    
    p1을 검사한다. (O)
    
    d3, d5, d7, d9, d11을 확인했을 때 1 0 1 1 1 으로 1이 4개라서 p1은 0이 맞다.
    
    p2를 검사한다. (X)
    
    d3, d6, d7, d10, d11을 확인했을 때 1 0 1 1 1 으로 1이 4개라 p2가 0이어야 하는데 1이라 오류다.
    
    p4를 검사한다. (O)
    
    d5, d6, d7, d12를 확인했을 때 0 0 1 0 으로 1이 1개라 p4가 1이 맞다.
    
    p8을 검사한다. (X)
    
    d9, d10, d11, d12를 확인했을 때 1 1 1 0으로 1이 3개라 p8이 1이어야 하는데 0이라 오류다.
    
    ***3) 오류 수정***
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/12405dd6-c5d9-454c-a1b4-0afbaeb1ab23/Untitled.png)
    
    p2, p8이 잘못된 값이므로 2 + 8이 10인 10번째 비트에서 오류가 발생했음을 알 수 있다.
    
    따라서 d10의 1을 0으로 바꾸면 오류 해결!!!
    

---

<참고>

[https://dololak.tistory.com/33](https://dololak.tistory.com/33)

[https://m.blog.naver.com/ggggamang/221113176831](https://m.blog.naver.com/ggggamang/221113176831)

[https://dreamlog.tistory.com/578](https://dreamlog.tistory.com/578)
