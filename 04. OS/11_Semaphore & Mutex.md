## 세마포어(Semaphore) & 뮤텍스(Mutex)

<br>

공유된 자원에 여러 프로세스가 동시에 접근하면서 문제가 발생할 수 있다. 이때 공유된 자원의 데이터는 한 번에 하나의 프로세스만 접근할 수 있도록 제한을 둬야 한다.

이를 위해 나온 것이 바로 **'세마포어'**

**세마포어** : 멀티프로그래밍 환경에서 공유 자원에 대한 접근을 제한하는 방법으로 세 개으 특수한 명령들만 접근할 수 있게 허용되는 보호되 변수이다.  

<br>

### 임계 구역(Critical Section)

> 여러 프로세스가 데이터를 공유하며 수행될 때, **각 프로세스에서 공유 데이터를 접근하는 프로그램 코드 부분**

공유 데이터를 여러 프로세스가 동시에 접근할 때 잘못된 결과를 만들 수 있기 때문에, 한 프로세스가 임계 구역을 수행할 때는 다른 프로세스가 접근하지 못하도록 해야 한다.

<br>

### 세마포어 P, V 연산

P : 임계 구역 들어가기 전에 수행 ( 프로세스 진입 여부를 자원의 개수(S)를 통해 결정 )
> * wait 또는 down 이라고도 부름  

V : 임계 구역에서 나올 때 수행 ( 자원 반납 알림, 대기 중인 프로세스를 깨우는 신호 )
> * signal 또는 up 이라고도 부름. 

* 세마포어에 대한 명령들은 비분리(invisible)여야 한다  
* 같은 세마포어 대해서 동시에 실행되지 못한다  
<br>

### 구현 방법

```sql
P(S);

// --- 임계 구역 ---

V(S);
```

<br>


#### block & wake up 방식
```sql
P(S): if (S > 0) then S = S - 1;
                  else S > 0 조건이 만족될 때까지 큐에서 대기;
V(S): if (큐에서 대기 중인 프로세스들이 존재)
                  then 그 중의 한 프로세스를 준비 또는 실행 상태를 만듦;
                  else S = S + 1;
```


#### busy - wait 방식
```sql
P(S) {
      while (S <= 0 );  --> busy - wait
      S--;
     }
V(S) {
      S++;
     }
```
* 장점 : wait상황이 만족되면 while 한 번만 더하면 임계영역에 바로 진입 가능  
        반면 block & wake up 방식은 ready로 보내서 그 안에서 다시 경쟁해야 함
        
* 단점 : CPU 낭비 -> 이 부분에 있어서는 block & wake up 방식이 더 유리. 


이를 통해, 한 프로세스가 P 혹은 V를 수행하고 있는 동안 프로세스가 인터럽트 당하지 않게 된다. P와 V를 사용하여 임계 구역에 대한 상호배제 구현이 가능하게 되었다.  

```sql
const int n = 프로세스의 수;
semaphore s = 1;
void p(int i)
{
  while (true)
  {
    P(s);
    <critical section>;
    V(s)
    <remainder>;
  }
}
void main()
{
  parbegin
    p(1), p(2), p(3),,,,p(n);
  parend
}
```

***예시***

> 최초 S 값은 1이고, 현재 해당 구역을 수행할 프로세스 A, B가 있다고 가정하자

1. 먼저 도착한 A가 P(S)를 실행하여 S를 0으로 만들고 임계구역에 들어감
2. 그 뒤에 도착한 B가 P(S)를 실행하지만 S가 0이므로 대기 상태
3. A가 임계구역 수행을 마치고 V(S)를 실행하면 S는 다시 1이 됨
4. B는 이제 P(S)에서 while문을 빠져나올 수 있고, 임계구역으로 들어가 수행함

<br>

### 식사하는 철학자들

```java
philosoper i:
while (true) {
  think;      // 생각하기
  P(fork[i]); // 오른쪽 포크 집기
  P(fork[(i+1) % 5);  // 왼쪽 포크 집기
  eat;        // 먹기
  V(fork[i]); // 오른쪽 포크 내려놓기
  V(fork[(i+1) % 5]); // 왼쪽 포크 내려놓기
}
```
-> 모든 철학자가 동시에 왼쪽 포크를 잡고 난 후, 오른쪽 포크를 집지 못해 교착 상태에 빠지 수 있다.


```java
philosoper i:
while (true) {
  think;      // 생각하기
  P(fork[i] and fork[(i+1) % 5]); // 오른쪽, 왼쪽 포크 집기
  eat;        // 먹기
  V(fork[i] and fork[(i+1) % 5]); // 오른쪽, 왼쪽 포크 내려놓기
}
```
-> 두 개를 모두 집은 철학자는 식사가 가능하나, 하나도 집지 못한 철학자는 굶게 되어, 동작이 매우 빠른 철학자에 의해 기아 상태가 발생할 수 있다.

#### 해결책
1. 4명만 앉도록 한다. -> 프로세스 개수 제한
2. 홀수번의 철학자는 왼쪽 포크 먼저, 짝수번의 철학자는 오른쪽 포크 먼저 집으면 문제 상황을 방지할 수 있다.(단, 기아 가능서 존재)

<br>

<br>

### **뮤텍스** : 임계 구역을 가진 스레드들의 실행시간이 서로 겹치지 않고 각각 단독으로 실행되게 하는 기술

> 상호 배제(**Mut**ual **Ex**clusion)의 약자임

해당 접근을 조율하기 위해 lock과 unlock을 사용한다.

- lock : 현재 임계 구역에 들어갈 권한을 얻어옴 ( 만약 다른 프로세스/스레드가 임계 구역 수행 중이면 종료할 때까지 대기 )
- unlock : 현재 임계 구역을 모두 사용했음을 알림. ( 대기 중인 다른 프로세스/스레드가 임계 구역에 진입할 수 있음 )

<br>

뮤텍스는 상태가 0, 1로 **이진 세마포어**로 부르기도 함

<br>

### **뮤텍스 알고리즘**

1. ##### 데커(Dekker) 알고리즘

   flag와 turn 변수를 통해 임계 구역에 들어갈 프로세스/스레드를 결정하는 방식

   - flag : 프로세스 중 누가 임계영역에 진입할 것인지 나타내는 변수
   - turn : 누가 임계구역에 들어갈 차례인지 나타내는 변수

   ```java
   while(true) {
       flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
       while(flag[j]) { // 프로세스 j가 현재 임계 구역에 있는지 확인
           if(turn == j) { // j가 임계 구역 사용 중이면
               flag[i] = false; // 프로세스 i 진입 취소
               while(turn == j); // turn이 j에서 변경될 때까지 대기
               flag[i] = true; // j turn이 끝나면 다시 진입 시도
           }
       }
   }
   
   // ------- 임계 구역 ---------
   
   turn = j; // 임계 구역 사용 끝나면 turn을 넘김
   flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
   ```

   <br>

2. ##### 피터슨(Peterson) 알고리즘

   데커와 유사하지만, 상대방 프로세스/스레드에게 진입 기회를 양보하는 것에 차이가 있음

   ```java
   while(true) {
       flag[i] = true; // 프로세스 i가 임계 구역 진입 시도
       turn = j; // 다른 프로세스에게 진입 기회 양보
       while(flag[j] && turn == j) { // 다른 프로세스가 진입 시도하면 대기
       <critical section>;
       <remainder>;
       }
   }
   
   // ------- 임계 구역 ---------
   
   flag[i] = false; // flag 값을 false로 바꿔 임계 구역 사용 완료를 알림
   ```

   <br>

3. ##### 제과점(Bakery) 알고리즘

   여러 프로세스/스레드에 대한 처리가 가능한 알고리즘. 가장 작은 수의 번호표를 가지고 있는 프로세스가 임계 구역에 진입한다.

   ```java
   while(true) {
       
       isReady[i] = true; // 번호표 받을 준비
       number[i] = max(number[0~n-1]) + 1; // 현재 실행 중인 프로세스 중에 가장 큰 번호 배정 
       isReady[i] = false; // 번호표 수령 완료
       
       for(j = 0; j < n; j++) { // 모든 프로세스 번호표 비교
           while(isReady[j]); // 비교 프로세스가 번호표 받을 때까지 대기
           while(number[j] && number[j] < number[i] && j < i);    // number값 비교, 만약 같으면 프로세스 number도 비교한다.
           }
           <critical section>
           // 프로세스 j가 번호표 가지고 있어야 함
           // 프로세스 j의 번호표 < 프로세스 i의 번호표
       }
   }
   
   // ------- 임계 구역 ---------
   
   number[i] = 0; // 임계 구역 사용 종료
   ```

   
